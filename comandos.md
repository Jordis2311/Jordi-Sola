# POSIX
## close
``int close(int fd);`` \
Closes a file descriptor, so that it no longer refers to any file and may be reused.
## open
``int open(const char *pathname, int flags);`` \
Opens the file specified by pathname.  If the specified file does not exist, it may optionally (if O_CREAT is specified in flags) be created by open(). The return value is a file descriptor, a small, nonnegative integer that is an index to an entry in the process's table of open file descriptors.
## read
``ssize_t read(int fd, void *buf, size_t count);`` \
Attempts to read up to count bytes from file descriptor fd into the buffer starting at buf. On success, the number of bytes read is returned and the file position is advanced by this number.
## write
``ssize_t write(int fd, const void *buf, size_t count);`` \
Writes up to count bytes from the buffer starting at buf       to the file referred to by the file descriptor fd. On success, the number of bytes written is returned.
## lseek
``off_t lseek(int fd, off_t offset, int whence);`` \
Repositions the file offset of the open file description associated with the file descriptor fd to the argument offset according to the directive whence as follows
- SEEK_SET : The file offset is set to offset bytes.
- SEEK_CUR : The file offset is set to its current location plus offset bytes.
- SEEK_END : The file offset is set to the size of the file plus offset bytes.

Upon successful completion, lseek() returns the resulting offset location as measured in bytes from the beginning of the file.
## exec
``int execl(const char *pathname, const char *arg, /*, (char *) NULL */);`` \
The exec() family of functions replaces the current process image with a new process image. The functions can be grouped based on the letters following the "exec" prefix.
- l : execl(), execlp(), execle() \
The const char *arg and subsequent ellipses can be thought of as arg0, arg1, ..., argn.
- v : execv(), execvp(), execvpe() \
The char *const argv[] argument is an array of pointers to null-terminated strings that represent the argument list available to the new program.
- e : execle(), execvpe() \
The environment of the new process image is specified via the argument envp
- p : execlp(), execvp(), execvpe() \
These functions duplicate the actions of the shell in searching for an executable file if the specified filename does not contain a slash (/) character.  The file is sought in the colon-separated list of directory pathnames specified in the PATH environment variable.
## fork
`` pid_t fork(void);`` \
creates a new process by duplicating the calling process. The new process is referred to as the child process, and has its own unique process ID. The calling process is referred to as the parent process. The child process and the parent process run in separate memory spaces. At the time of fork() both memory spaces have the same content. On success, the PID of the child process is returned in the parent, and 0 is returned in the child.
## getpid
``pid_t getpid(void);`` \
getpid() returns the process ID (PID) of the calling process.
## wait
``pid_t wait(int *wstatus);`` \
Suspends execution of the calling thread until one of its children terminates.
## waitpid
``pid_t waitpid(pid_t pid, int *wstatus, int options);`` \
suspends execution of the calling thread until a child specified by pid argument terminates.
## exit
``noreturn void exit(int status);`` \
The exit() function causes normal process termination and the least significant byte of status is returned to the parent
# IPC
## signal
``sighandler_t signal(int signum, sighandler_t handler);`` \
Sets the disposition of the signal signum to handler, which is either SIG_IGN, SIG_DFL, or the address of a programmer-defined function.
## sigaction
``int sigaction(int signum, const struct sigaction *restrict act, struct sigaction *restrict oldact);`` \
Is used to change the action taken by a process on receipt of a specific signal. signum specifies the signal and can be any valid signal except SIGKILL and SIGSTOP. If act is non-NULL, the new action for signal signum is installed from act.  If oldact is non-NULL, the previous action is saved in oldact.
## raise
``int raise(int sig);`` \
Causes signal sig to be generated.
| Macro | Signal |
| ----- | ------ |
| SIGABRT | Abnormal termination, such as is initiated by the abort function |
| SIGFPE | (Signal Floating-Point Exception) Erroneous arithmetic operation, such as zero divide or an operation resulting in overflow (not necessarily with a floating-point operation) |
| SIGILL | (Signal Illegal Instruction) Invalid function image, such as an illegal instruction. This is generally due to a corruption in the code or to an attempt to execute data |
| SIGINT | (Signal Interrupt) Interactive attention signal. Generally generated by the application user |
| SIGSEGV | (Signal Segmentation Violation) Invalid access to storage âˆ’ When a program tries to read or write outside the memory it is allocated for it |
## pipes
``int pipe(int pipefd[2]);``
creates a pipe, a unidirectional data channel that can be used for interprocess communication. The array pipefd is used to return two file descriptors referring to the ends of the pipe. pipefd[0] refers to the read end of the pipe. pipefd[1] refers to the write end of the pipe. Data written to the write end of the pipe is buffered by the kernel until it is read from the read end of the pipe.
# Sockets
## socket
``int socket(int domain, int type, int protocol);`` \
creates an endpoint for communication and returns a file descriptor that refers to that endpoint. The file descriptor returned by a successful call will be the lowest-numbered file descriptor not currently open for the process. \
The domain argument specifies the protocol family which will be used for communication. 
- AF_UNIX : Local communication 
- AF_LOCAL : Synonym for AF_UNIX
- AF_INET : IPv4 Internet protocols
- AF_INET6 : IPv6 Internet protocols

The socket has the indicated type, which specifies the communication semantics.
-  SOCK_STREAM : Provides sequenced, reliable, two-way, connection-based byte streams. An out-of-band data transmission mechanism may be supported.
- SOCK_DGRAM : Supports datagrams; connectionless, unreliable messages of a fixed maximum length.

The protocol specifies a particular protocol to be used with the socket. Normally only a single protocol exists to support a particular socket type within a given protocol family, in which case protocol can be specified as 0.
## bind
``int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);`` \
assigns the address specified by addr to the socket referred to by the file descriptor sockfd.  addrlen specifies the size, in bytes, of the address structure pointed to by addr.
## send
``ssize_t send(int sockfd, const void *buf, size_t len, int flags);`` \
May be used only when the socket is in a connected state (so that the intended recipient is known). The only difference between send() and write() is the presence of flags. With a zero flags argument, send() is equivalent to write().
## recv
``ssize_t recv(int sockfd, void *buf, size_t len, int flags);`` \
They may be used to receive data on both connectionless and connection-oriented sockets. The only difference between recv() and read() is the presence of
flags. With a zero flags argument, recv() is generally equivalent to read().
## listen
``int listen(int sockfd, int backlog);`` \
Marks the socket referred to by sockfd as a passive socket, that is, as a socket that will be used to accept incoming connection requests using accept(). The sockfd argument is a file descriptor that refers to a socket of type SOCK_STREAM or SOCK_SEQPACKET. The backlog argument defines the maximum length to which the queue of pending connections for sockfd may grow.
## accept
``int accept(int sockfd, struct sockaddr *restrict addr, socklen_t *restrict addrlen);`` \
It extracts the first connection request on the queue of pending connections for the listening socket, sockfd, creates a new connected socket, and returns a new file descriptor referring to that socket. \
The argument sockfd is a socket that has been created with socket(), bound to a local address with bind(), and is listening for connections after a listen(). \
The argument addr is a pointer to a sockaddr structure. This structure is filled in with the address of the peer socket, as known to the communications layer.  The exact format of the address returned addr is determined by the socket's address family. When addr is NULL, nothing is filled in; in this case, addrlen is not used, and should also be NULL. \
The addrlen argument is a value-result argument: the caller must initialize it to contain the size (in bytes) of the structure pointed to by addr; on return it will contain the actual size of the peer address.
## connect
``int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);`` \
Connects the socket referred to by the file descriptor sockfd to the address specified by addr. The addrlen argument specifies the size of addr.  The format of the address in addr is determined by the address space of the socket sockfd. If the socket sockfd is of type SOCK_DGRAM, then addr is the address to which datagrams are sent by default, and the only address from which datagrams are received. If the socket is of type SOCK_STREAM or SOCK_SEQPACKET, this call attempts to make a connection to the socket that is bound to the address specified by addr.
# Threads
``#include <pthread.h>``
## pthread_create
`` int pthread_create(pthread_t *restrict thread, const pthread_attr_t *restrict attr, void *(*start_routine)(void *), void *restrict arg);`` \
Starts a new thread in the calling process.
## pthread_join
``int pthread_join(pthread_t thread, void **retval);`` \
Waits for the thread specified by thread to terminate.
## pthread_exit
``noreturn void pthread_exit(void *retval);`` \
Terminates the calling thread and returns a value via retval that (if the thread is joinable) is available to another thread in the same process that calls pthread_join().
## epoll_create
``int epoll_create(int size);`` \
Creates a new epoll instance and returns a file descriptor referring to that instance.
## epoll_ctl
``int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);`` \
Is used to add, modify, or remove entries in the interest list of the epoll instance referred to by the file descriptor epfd. It requests that the operation op be performed for the target file descriptor, fd. \
Valid values for the op argument are:
- EPOLL_CTL_ADD : add an entry to the interest list of the epoll file descriptor, epfd. The entry includes the file descriptor, fd, a reference to the corresponding open file description, and the settings specified in event.
- EPOLL_CTL_MOD : change the settings associated with fd in the interest list to the new settings specified in event.
- EPOLL_CTL_DEL : remove the target file descriptor fd from the interest list. The event argument is ignored and can be NULL.

The event argument describes the object linked to the file descriptor fd. The struct epoll_event is defined as:
```
typedef union epoll_data {
    void        *ptr;
    int          fd;
    uint32_t     u32;
    uint64_t     u64;
} epoll_data_t;

struct epoll_event {
    uint32_t     events;      /* Epoll events */
    epoll_data_t data;        /* User data variable */
};
```
The data member of the epoll_event structure specifies data that the kernel should save and then return when this file descriptor becomes ready.

The events member of the epoll_event structure is a bit mask composed by ORing together zero or more of the following available event types:
- EPOLLIN : the associated file is available for read(2) operations.
- EPOLLOUT : the associated file is available for write(2) operations.

## epoll_wait
Waits for I/O events, blocking the calling thread if no events are currently available.
# Locks
## pthread_mutex_lock
``int pthread_mutex_lock(pthread_mutex_t *mutex);`` \
The mutex object referenced by mutex is locked by calling pthread_mutex_lock(). If the mutex is already locked, the calling thread blocks until the mutex becomes available.
## pthread_mutex_trylock
``int pthread_mutex_trylock(pthread_mutex_t *mutex);`` \
Is identical to pthread_mutex_lock() except that if the mutex object referenced by mutex is currently locked (by any thread, including the current thread), the call returns immediately.
## pthread_mutex_unlock
``int pthread_mutex_unlock(pthread_mutex_t *mutex);`` \
Releases the mutex object referenced by mutex.
## pthread_cond_init
``int pthread_cond_init(pthread_cond_t *cond, pthread_condattr_t *cond_attr);`` \
Initializes the condition variable cond, using the condition attributes specified in cond_attr, or default attributes if cond_attr is NULL. Variables of type pthread_cond_t can also be initialized statically, using the constant PTHREAD_COND_INITIALIZER.
## pthread_cond_signal
``int pthread_cond_signal(pthread_cond_t *cond);`` \
Restarts one of the threads that are waiting on the condition variable cond. If no threads are waiting on cond, nothing happens. If several threads are waiting on cond, exactly one is restarted, but it is not specified which.
## pthread_cond_broadcast
``int pthread_cond_broadcast(pthread_cond_t *cond);`` \
Restarts all the threads that are waiting on the condition variable cond. Nothing happens if no threads are waiting on cond.
## pthread_cond_wait
``int pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex);`` \
Atomically unlocks the mutex and waits for the condition variable cond to be signaled. The thread execution is suspended and does not consume any CPU time until the condition variable is signaled.
## pthread_cond_destroy
``int pthread_cond_destroy(pthread_cond_t *cond);`` \
Destroys a condition variable, freeing the resources it might hold.
## sem_init
``int sem_init(sem_t *sem, int pshared, unsigned int value);`` \
Initializes the unnamed semaphore at the address pointed to by sem.  The value argument specifies the initial value for the semaphore.
## sem_post
``int sem_post(sem_t *sem);`` \
Increments (unlocks) the semaphore pointed to by sem. If the semaphore's value consequently becomes greater than zero, then another process or thread blocked in a sem_wait() call will be woken up and proceed to lock the semaphore.
## sem_wait
``int sem_wait(sem_t *sem);`` \
Locks the semaphore referenced by sem by performing a semaphore lock operation on that semaphore. If the semaphore value is currently zero, then the calling thread shall not return from the call to sem_wait() until it either locks the semaphore or the call is interrupted by a signal.
## sem_trywait
``int sem_trywait(sem_t *sem);`` \
Locks the semaphore referenced by sem only if the semaphore is currently not locked; that is, if the semaphore value is currently positive. Otherwise, it shall not lock the semaphore. \
## sem_destroy
``int sem_destroy(sem_t *sem);`` \
Destroys the unnamed semaphore at the address pointed to by sem. \
